
The pay station program had my teammate and I create methods and write test code that had to follow specific requirements that were provided by the professor. We had to create a mapping in the source code that tracked all of the different types of  and amount of coins that have entered the pay stations. We had to tweak the methods that we created to make them work for other requirements such as when calling cancel the program returns a map doesn’t return a coin that hasn’t been entered. We completed all of the requirements for the project. We didn’t make any personal improvements to the projects.

Trevor- I contributed 7 commits to the project. The first commit I pushed to git hub was counting the total amount of money entered. At this point in the project I really didn’t understand the full requirements and messed this method up and had to revise it later on. The second and third commit I had was creating test cases for when I call cancel it doesn’t add the amount returned by empty. My Last commits were where I created test cases for the cancel methods. During these commits I had to edit some of the source code to make sure it satisfied the requirements.
Daniel - I also contributed 7 commits to the project - the first couple were me testing to see if my git configuration were correct. I first implemented empty, adding the code that would allow it to return the amount of money collected. I then created the README file so it could be filled out later on. The third commit was where I did three of the tests, having initial trouble understanding the Map class that was mentioned in the requirements of the lab. However, I figured it out and added the "coin storage" functionality, allowing the program to "remember" which coins were entered, and changed the addPayment method to utilize this new functionality. I had to resolve some git conflicts with my partner, so the next commit is basically me resolving the conflicts. The next two commits were very small minor changes, just fixed a mistake here and there. Finally, I fixed one of my partner's test cases and added the final two tests outlined by the requirements, but was confused with one of the requirements, specifically the one saying that the mapping should never be null but could was also supposed to return null for a certain coin if that coin wasn't entered in the transaction. "The Map object is never null even if no coins are returned." and "Call to cancel returns a map that does not contain a key for a coin not entered." Based on these two requirements, if no coins are entered, every mapping (5, 10, 25) would not exist therefore the mapping would be null... unless it's referring to the actual instantiation of the Map object itself (eg Map<Integer, Integer> temp = null cannot be a thing). I found these instructions to be contradictory, and due to me happening to choose this test case as the last one to work on, I didn't have time to ask for clarification on the instructions, so I interpreted it as the map object will never be null, but say if a quarter wasn't entered, the mapping for 25 can return null as it wasn't entered. After I adjusted all the other test cases to follow this logic, I pushed this readme and the last test I worked on, completing the lab.

